<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<!-- generated by to_html.pl from GraphicSystem.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>Graphic system</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="browser.css" type="text/css" rel="stylesheet" title="å‰é‡Œå‰é‡Œé–¢é€£ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ç”¨æ¨™æº–ã‚¹ã‚¿ã‚¤ãƒ«" />
	<link href="mailto:dee@kikyou.info" rev="Made" />
	<link href="index.html" target="_top" rel="Start" title="ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸" />
</head>
<body>
<h1><a id="id142" name="id142">About graphic system</a>
</h1><div class="para"><div>
ã€€Kirikiri has a graphic display mechanism using layers.<br />
ã€€Each layer has transparency superimposition by alpha blending and hierarchical structure management function. In addition, it has a mechanism (focus) for receiving input from the user so that the layer can be operated as a GUI part (widget).<br />
<br />
ã€€The superimposed layers are drawn in the window using a mechanism called a drawing device. By default, a device called BasicDrawDevice is used that simply draws the output of the layer into the window. The drawing device can be freely replaced by manipulating the <a target="main" class="jump" href="f_Window_drawDevice.html">Window.drawDevice</a> property, and the user can define his own rendering effects etc. (in the form of a plug-in) according to the application. Kirikiri Z has only the above-mentioned BasicDrawDevice.</div></div>
<h1><a id="id143" name="id143">Readable and writable image formats</a>
</h1><div class="para"><div>
ã€€In the standard state Kirikiri, the format that can be read into the layer with <a target="main" class="jump" href="f_Layer_loadImages.html">Layer.loadImages</a> and can be written to the layer is as follows.<br />
<br />
<dl>
<dt>BMP</dt>
<dd>ã€€Windows standard bitmap format. A 32 bpp BMP is considered a bitmap with an alpha channel.<br />
ã€€RLE compressed bitmaps cannot be read.</dd>
<dt>PNG</dt>
<dd>ã€€Portable Network Graphic format can be read. You can also import bitmap PNGs with an alpha channel.</dd>
<dt>JPEG</dt>
<dd>ã€€JPEG format can be read. Arithmetic-compressed or lossless-compressed ones cannot be read, but I rarely see them in the first place.</dd>
<dt>TLG5</dt>
<dd>ã€€Kirikiri is a unique lossless compression format. The extension is .tlg. You can also load those with an alpha channel. The compression ratio is not very high, but the feature is that it can be expanded at high speed. This format cannot be used for <em>mask images (_m) or region images (_p)</em>. Only full color images without alpha channel or full color images with alpha channel can be handled.</dd>
<dt>TLG6</dt>
<dd>ã€€Kirikiri is a unique lossless compression format. The extension is .tlg like TLG5. TLG6 features a high compression ratio. Decompression speed is slightly less than twice as fast as TLG5, but it can still be decompressed more than twice as fast as PNG, and its size is 2-40% smaller than PNG.</dd>
<dt>JPEG XR</dt>
<dd>ã€€JPEG XR format can be read. It is lossy but has higher quality than JPEG and supports alpha channel.<br />
ã€€Compressing with priority on image quality makes it difficult to distinguish from lossless compressed images, and is useful when the size is important because the file size is small.<br />
ã€€Supported from Ver 1.1.0, currently only supports reading.<br />
ã€€Ver. 1.3.0 also supports saving.<br />
</dd>
<dt>Main / mask separation format</dt>
<dd>ã€€The main / mask separation format is a format in which the color information image (main) and the alpha channel (mask) image are separated, and the mask image is the main image file name with _m appended (abc_m.jpeg for abc.jpeg).<br />
ã€€The format of the main / mask image can be different.</dd></dl><br />
ã€€In addition, you can increase the number of image formats that can be loaded using Susie Plug-in. Susie plug-in can be read by <a target="main" class="jump" href="f_Plugins_link.html">Plugins.link</a> method.<br />
ã€€If a 32bpp bitmap is passed from Susie Plug-in, it is considered a bitmap with an alpha channel.<br />
<br />
</div></div>
<h1><a id="id144" name="id144">Layer type</a>
</h1><div class="para"><div>
ã€€The Kirikiri layer can be displayed in various composite modes (layer types).<br />
ã€€The following compositing modes are available, and layer type constants starting with lt can be specified in the <a target="main" class="jump" href="f_Layer_type.html">Layer.type</a> property.<br />
ã€€In the formula, <span class="i">result</span> is the result, <span class="i">dest</span> is the luminance of the image to be superimposed, <span class="i">src</span> is the luminance of the image to be superimposed, <span class="i">Î±</span> is the alpha value for each pixel of the image to be superimposed, and the range of all values is 0.0 to 1.0.<br />
ã€€In addition, the following functions are defined here for explanation.<br />
<ul><li>abs(<span class="i">a</span>) : Absolute value of <span class="i">a</span></li><li>max(<span class="i">a</span>, <span class="i">b</span>) : <span class="i">a</span> and <span class="i">b</span>, whichever is greater</li><li>min(<span class="i">a</span>, <span class="i">b</span>) : <span class="i">a</span> and <span class="i">b</span>, whichever is lesser</li><li>blend(<span class="i">a</span>, <span class="i">b</span>, <span class="i">r</span>) = <span class="i">a</span> × (1.0 - <span class="i">r</span>) + <span class="i">b</span> × <span class="i">r</span></li></ul><br />
<dl>
<dt><a id="id145" name="id145" class="targanchor"><dfn>ltOpaque</dfn></a> (<a id="id146" name="id146" class="targanchor"><dfn>ltCoverRect</dfn></a>)</dt>
<dd>ã€€ltOpaque is a display without transparency. The entire rectangle of the layer is always fully opaque (not limited to this layer type, but if <a target="main" class="jump" href="f_Layer_opacity.html">Layer.opacity</a> is used to reduce opacity).<br />
<br />
Formula: <span class="i">result</span> = <span class="i">src</span><br />
<br /><div class="note"><div class="notehead"><span class="noteheadspan">Note</span></div>
The same is true for ltCoverRect, but it is an older name before 2.23 beta 2.</div><br />
</dd>
<dt><a id="id147" name="id147" class="targanchor"><dfn>ltAlpha</dfn></a> (<a id="id148" name="id148" class="targanchor"><dfn>ltTransparent</dfn></a>)</dt>
<dd>ã€€ltAlpha performs alpha compositing. This is the most basic type when performing transmission. The following equation is also used for alpha channel input from BMP and Susie plug-in.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, <span class="i">src</span>, <span class="i">Î±</span>)<br />
<br /><div class="note"><div class="notehead"><span class="noteheadspan">Note</span></div>
ltTransparent has the same meaning, but is an older name before 2.23 beta 2.</div><br />
</dd>
<dt><a id="id149" name="id149" class="targanchor"><dfn>ltAddAlpha</dfn></a></dt>
<dd>ã€€ltAddAlpha performs additive alpha compositing.<br />
ã€€<a target="main" class="jump" href="TPC.html">Image format converter</a> can output images suitable for this format. You can also convert from ltAlpha to this format with the <a target="main" class="jump" href="f_Layer_convertType.html">Layer.convertType</a> method.<br />
ã€€The ltAddAlpha layer will not display properly if it is a direct child of the ltAlpha layer.<br />
<br />
Formula: <span class="i">result</span> = min(1.0, <span class="i">dest</span> × ( 1.0 - <span class="i">Î±</span> ) + <span class="i">src</span>)<br />
</dd>
<dt><a id="id150" name="id150" class="targanchor"><dfn>ltAdditive</dfn></a></dt>
<dd>ã€€ltAdditive performs additive composition. Suitable for expressing glow. Dodge (linear) in Photoshop, but if you want to get the same effect as Photoshop, use ltPsAdditive described later. Unlike ltPsAdditive, <span class="i">Î±</span> is ignored in ltAdditive.<br />
ã€€Neutral colors (colors that do not change when superimposed) are black.<br />
<br />
Formula: <span class="i">result</span> = min(1.0, <span class="i">dest</span> + <span class="i">src</span>)<br />
</dd>
<dt><a id="id151" name="id151" class="targanchor"><dfn>ltSubtractive</dfn></a></dt>
<dd>ã€€ltSubtractive performs subtractive composition. <span class="i">Î±</span> is ignored.<br />
ã€€Neutral color is white.<br />
<br />
Formula: <span class="i">result</span> = max(0.0, <span class="i">dest</span> + <span class="i">src</span> - 1.0)<br />
<br /><div class="note"><div class="notehead"><span class="noteheadspan">Note</span></div>
ã€€The only difference from <span class="i">result</span> = <span class="i">dest</span> - <span class="i">src</span> is whether src is inverted or not.</div><br />
</dd>
<dt><a id="id152" name="id152" class="targanchor"><dfn>ltMultiplicative</dfn></a></dt>
<dd>ã€€ltMultiplicative performs multiplicative synthesis. <span class="i">Î±</span> is ignored.<br />
ã€€Neutral color is white.<br />
<br />
Formula <span class="i">result</span> = <span class="i">dest</span> × <span class="i">src</span></dd>
<dt><a id="id153" name="id153" class="targanchor"><dfn>ltDodge</dfn></a></dt>
<dd>ã€€ltDodge performs &quot;dodging&quot; compositing. Suitable for expressing objects illuminated by light. <span class="i">Î±</span> is ignored.<br />
ã€€Neutral color is black.<br />
<br />
Formula: <span class="i">result</span> = min(1.0, <span class="i">dest</span> ÷ ( 1.0 -  <span class="i">src</span> ) )<br />
</dd>
<dt><a id="id154" name="id154" class="targanchor"><dfn>ltLighten</dfn></a></dt>
<dd>ã€€ltLighten performs &quot;comparison (light)&quot; synthesis. <span class="i">Î±</span> is ignored.<br />
ã€€Neutral color is black.<br />
<br />
Formula: <span class="i">result</span> = max(<span class="i">dest</span>, <span class="i">src</span>)<br />
</dd>
<dt><a id="id155" name="id155" class="targanchor"><dfn>ltDarken</dfn></a></dt>
<dd>ã€€ltDarken performs a &quot;compare (dark)&quot; synthesis. <span class="i">Î±</span> is ignored.<br />
ã€€Neutral color is white.<br />
<br />
Formula: <span class="i">result</span> = min(<span class="i">dest</span>, <span class="i">src</span>)<br />
</dd>
<dt><a id="id156" name="id156" class="targanchor"><dfn>ltScreen</dfn></a></dt>
<dd>ã€€ltLighten performs &quot;screen multiplication&quot; synthesis. <span class="i">Î±</span> is ignored.<br />
ã€€Neutral color is black.<br />
<br />
Formula: <span class="i">result</span> = 1.0 - ( 1.0 - <span class="i">dest</span> ) × ( 1.0 - <span class="i">src</span> )<br />
</dd>


<dt><a id="id157" name="id157" class="targanchor"><dfn>ltPsNormal</dfn></a></dt>
<dd>ã€€ltPsNormal has the same effect as ltAlpha. For historical reasons, it has a different routine and name than ltAlpha.</dd>

<dt><a id="id158" name="id158" class="targanchor"><dfn>ltPsAdditive</dfn></a></dt>
<dd>ã€€ltPsAdditive performs Photoshop-compatible &quot;dodging (linear)&quot; synthesis (additional synthesis). Unlike ltAdditive, <span class="i">Î±</span> is not ignored.<br />
ã€€Neutral color is black.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, min(1.0, <span class="i">dest</span> + <span class="i">src</span>), <span class="i">Î±</span>)<br />
</dd>
<dt><a id="id159" name="id159" class="targanchor"><dfn>ltPsSubtractive</dfn></a></dt>
<dd>ã€€ltPsSubtractive performs Photoshop-compatible &quot;burn-in (linear)&quot; synthesis (subtraction synthesis). Unlike ltSubtractive, <span class="i">Î±</span> is not ignored.<br />
ã€€Neutral color is white.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, max(0.0, <span class="i">dest</span> + <span class="i">src</span> - 1.0), <span class="i">Î±</span>)<br />
</dd>
<dt><a id="id160" name="id160" class="targanchor"><dfn>ltPsMultiplicative</dfn></a></dt>
<dd>ã€€ltPsMultiplicative provides Photoshop compatible &quot;multiply&quot; compositing. Unlike ltMultiplicative, <span class="i">Î±</span> is not ignored.<br />
ã€€Neutral color is white.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, <span class="i">dest</span> × <span class="i">src</span>, <span class="i">Î±</span>)<br />
</dd>
<dt><a id="id161" name="id161" class="targanchor"><dfn>ltPsScreen</dfn></a></dt>
<dd>ã€€ltPsScreen provides Photoshop compatible &quot;screen&quot; compositing. Unlike ltScreen, <span class="i">Î±</span> is not ignored.<br />
ã€€Neutral color is black.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, 1.0 - (1.0 - <span class="i">dest</span>) × (1.0 - <span class="i">src</span>), <span class="i">Î±</span>)<br />
</dd>

<dt><a id="id162" name="id162" class="targanchor"><dfn>ltPsOverlay</dfn></a></dt>
<dd>ã€€ltPsOverlay provides Photoshop compatible &quot;overlay&quot; compositing.<br />
ã€€Neutral color is 50% gray.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, overlay(<span class="i">dest</span>, <span class="i">src</span>), <span class="i">Î±</span>)<br />
Where overlay(<span class="i">a</span>, <span class="i">b</span>) = <br />
ã€€<span class="i">a</span> × <span class="i">b</span> × 2.0  ( When <span class="i">a</span> &lt; 0.5 )<br />
ã€€1.0 - (1.0 - <span class="i">a</span>) × (1.0 - <span class="i">b</span>) × 2.0 (At other times)<br />
</dd>
<dt><a id="id163" name="id163" class="targanchor"><dfn>ltPsHardLight</dfn></a></dt>
<dd>ã€€ltPsHardLight provides Photoshop compatible &quot;hard light&quot; compositing.<br />
ã€€Neutral color is 50% gray.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, hardlight(<span class="i">dest</span>, <span class="i">src</span>), <span class="i">Î±</span>)<br />
Where hardlight(<span class="i">a</span>, <span class="i">b</span>) = <br />
ã€€<span class="i">a</span> × <span class="i">b</span> × 2.0  ( When <span class="i">b</span> &lt; 0.5 )<br />
ã€€1.0 - (1.0 - <span class="i">a</span>) × (1.0 - <span class="i">b</span>) × 2.0 (At other times)<br />
</dd>

<dt><a id="id164" name="id164" class="targanchor"><dfn>ltPsSoftLight</dfn></a></dt>
<dd>ã€€ltPsSoftLight provides Photoshop compatible &quot;soft light&quot; compositing.<br />
ã€€Neutral color is 50% gray.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, softlight(<span class="i">dest</span>, <span class="i">src</span>), <span class="i">Î±</span>)<br />
When softlight(<span class="i">a</span>, <span class="i">b</span>) = <br />
ã€€<span class="i">a</span><sup>(0.5 ÷ <span class="i">b</span>)</sup>  ( When <span class="i">b</span> &gt; 0.5 )<br />
ã€€<span class="i">a</span><sup>((1.0 - <span class="i">b</span>) × 2)</sup>  (At other times)<br />
</dd>

<dt><a id="id165" name="id165" class="targanchor"><dfn>ltPsColorDodge</dfn></a></dt>
<dd>ã€€ltPsColorDodge provides Photoshop compatible &quot;dodge color&quot; compositing. Unlike ltDodge, <span class="i">Î±</span> is not ignored.<br />
ã€€Neutral color is black.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, min(1.0, <span class="i">dest</span> ÷ ( 1.0 -  <span class="i">src</span> ) ), <span class="i">Î±</span>)<br />
</dd>
<dt><a id="id166" name="id166" class="targanchor"><dfn>ltPsColorDodge5</dfn></a></dt>
<dd>ã€€ltPsColorDodge provides &quot;dodging color&quot; compositing compatible with Photoshop versions 5.x and below. The formula is slightly different from ltPsColorDodge.<br />
ã€€Neutral color is black.<br />
<br />
Formula: <span class="i">result</span> = min(1.0, <span class="i">dest</span> ÷ ( 1.0 - <span class="i">src</span> × <span class="i">Î±</span>) )<br />
</dd>
<dt><a id="id167" name="id167" class="targanchor"><dfn>ltPsColorBurn</dfn></a></dt>
<dd>ã€€ltPsColorBurn provides Photoshop compatible &quot;burn-in color&quot; compositing.<br />
ã€€Neutral color is white.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, max(0.0, 1.0 - (1.0 - <span class="i">dest</span>) ÷ <span class="i">src</span>), <span class="i">Î±</span>)<br />
</dd>
<dt><a id="id168" name="id168" class="targanchor"><dfn>ltPsLighten</dfn></a></dt>
<dd>ã€€ltPsLighten performs Photoshop-compatible &quot;comparison (light)&quot; compositing. Unlike ltLighten, <span class="i">Î±</span> is not ignored.<br />
ã€€Neutral color is black.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, max(<span class="i">dest</span>, <span class="i">src</span>), <span class="i">Î±</span>)<br />
</dd>
<dt><a id="id169" name="id169" class="targanchor"><dfn>ltPsDarken</dfn></a></dt>
<dd>ã€€ltPsDarken performs Photoshop-compatible &quot;compare (dark)&quot; compositing. Unlike ltDarken, <span class="i">Î±</span> is not ignored.<br />
ã€€Neutral color is white.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, min(<span class="i">dest</span>, <span class="i">src</span>), <span class="i">Î±</span>)<br />
</dd>
<dt><a id="id170" name="id170" class="targanchor"><dfn>ltPsDifference</dfn></a></dt>
<dd>ã€€ltPsDifference provides Photoshop compatible &quot;absolute difference&quot; compositing.<br />
ã€€Neutral color is black.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>, abs(<span class="i">dest</span> - <span class="i">src</span>), <span class="i">Î±</span>)<br />
</dd>
<dt><a id="id171" name="id171" class="targanchor"><dfn>ltPsDifference5</dfn></a></dt>
<dd>ã€€ltPsDifference5 provides &quot;absolute difference&quot; compositing compatible with Photoshop versions 5.x and below. The formula is slightly different from ltPsDifference.<br />
ã€€Neutral color is black.<br />
<br />
Formula: <span class="i">result</span> = abs(<span class="i">dest</span> - <span class="i">src</span> × <span class="i">Î±</span>)<br />
</dd>
<dt><a id="id172" name="id172" class="targanchor"><dfn>ltPsExclusion</dfn></a></dt>
<dd>ã€€ltPsExclusion performs Photoshop-compatible &quot;exclusion&quot; compositing.<br />
ã€€Neutral color is black.<br />
<br />
Formula: <span class="i">result</span> = blend(<span class="i">dest</span>,  <span class="i">dest</span> + <span class="i">src</span> - 2.0 × <span class="i">src</span> × <span class="i">dest</span>, <span class="i">Î±</span>)<br />
</dd>

</dl></div></div>





<h1><a id="id173" name="id173">Alpha compositing and additive alpha compositing</a>
</h1><div class="para"><div>
ã€€Kirikiri has two alpha compositing modes.<br />
<dl>
<dt>Alpha compositing</dt>
<dd>Specifying <a id="id174" name="id174" class="targanchor"><dfn>ltAlpha</dfn></a> in the <a target="main" class="jump" href="f_Layer_type.html">Layer.type</a> property makes this display type.<br />
ltAlpha is an alpha compositing mode used by many graphic software. This mode is suitable for directly reading data output by other graphic software.<br />
</dd>
<dt>Additive alpha synthesis</dt>
<dd>Specifying <a id="id175" name="id175" class="targanchor"><dfn>ltAddAlpha</dfn></a> in the <a target="main" class="jump" href="f_Layer_type.html">Layer.type</a> property makes this display type.<br />
ã€€This format has the following advantages and disadvantages compared to alpha compositing.<br />
<ul><li>Since the formula is simpler than alpha compositing, it can be displayed quickly and many drawing methods can draw fast.</li><li>Additive composition can be expressed together with alpha composition</li><li>Few graphics software support this format</li></ul><br />
Graphic software that supports the same composition mode as ltAddAlpha does not think so, so to handle the output of other software in this format with Kirikiri, output this type of image with <a target="main" class="jump" href="TPC.html">Image format converter</a> or use the <a target="main" class="jump" href="f_Layer_convertType.html">Layer.convertType</a> method. You need to convert from ltAlpha to this format.<br />
ã€€The image format converter can accept a combined input of a &quot;normal&quot; layer and a &quot;dodging (linear)&quot; layer in Photoshop format as an input for additive alpha compositing images.<br />
</dd></dl></div></div>





<h1><a id="id176" name="id176">Layer type, drawing method and calculation mode</a>
</h1><div class="para"><div>
ã€€Kirikiri has a layer type (specified with a constant starting with lt), a drawing method (specified with a constant starting with df), and a calculation mode (specified with a constant starting with om).<br />
ã€€Although each has a similar name, the uses are divided as follows.<br />
<dl>
<dt>Layer type</dt>
<dd>ã€€The layer type is a value specified by the <a target="main" class="jump" href="f_Layer_type.html">Layer.type</a> property, which specifies how the layer is displayed.</dd>
<dt>Drawing method</dt>
<dd>ã€€The drawing method is the value specified by the <a target="main" class="jump" href="f_Layer_face.html">Layer.face</a> property, and specifies how to draw on the layer. If dfAuto is specified, the appropriate drawing method will be determined according to the layer type. You can also draw with a different drawing method than the best drawing method for the layer type.<br />
ã€€Methods that copy between layers, such as <a target="main" class="jump" href="f_Layer_copyRect.html">Layer.copyRect</a> methods, are also used to select which information to copy. dfBoth (or dfAlpha or dfAddAlpha) copies both the main and the mask. For dfMain (or dfOpaque), only the main is copied. For dfMask, only the mask is copied; for dfProvince, only the area image is copied.<br />
ã€€Similarly, <a target="main" class="jump" href="f_Layer_fillRect.html">Layer.fillRect</a> methods are used to select which information to fill. dfBoth (or dfAlpha or dfAddAlpha) fills both the main and the mask. In the case of dfMain (or dfOpaque), only the main is copy filled. For dfMask, only the mask is filled, and for dfProvince, only the area image is filled.<br />
</dd>
<dt>Calculation mode</dt>
<dd>ã€€The calculation mode is a value specified by an argument such as the <a target="main" class="jump" href="f_Layer_operateRect.html">Layer.operateRect</a> method, and a value that specifies how to handle the calculation source (layer to be overlaid). If omAuto is specified, the appropriate mode is determined according to the layer type of the calculation source.</dd></dl></div></div>

<h1><a id="id177" name="id177">Alpha channel protection</a>
</h1><div class="para"><div>
ã€€If the drawing method specified by the <a target="main" class="jump" href="f_Layer_face.html">Layer.face</a> property is <a id="id178" name="id178" class="targanchor"><dfn>dfOpaque</dfn></a>, the <a target="main" class="jump" href="f_Layer_holdAlpha.html">Layer.holdAlpha</a> property can specify whether to protect the alpha channel of the drawing destination (the layer on which the method is to be executed).<br />
ã€€Protecting the alpha channel protects the alpha channel (opacity) and leaves transparent areas transparent.<br />
ã€€If you do not protect the alpha channel, the alpha channel (opacity) will be destroyed. Destruction means that you don't know what state it will be in.<br />
ã€€However, if the <a target="main" class="jump" href="f_Layer_type.html">Layer.type</a> property is not <a id="id179" name="id179" class="targanchor"><dfn>ltAlpha</dfn></a> or <a id="id180" name="id180" class="targanchor"><dfn>ltAddAlpha</dfn></a>, the layer's alpha channel is not used, so setting the Layer.holdAlpha property to false is usually fine. If false, many methods will draw faster than true.<br />
</div></div>

	<script type="text/javascript" charset="UTF-8" src="documentid.js" ></script>
	<script type="text/javascript" charset="UTF-8" src="postcontent.js" ></script>
</body>
</html>
